---
title: "Environmental and Sociodemographic Determinants of Mortality in the US"
author: "Five Chives: Dasha Asienga, Caitlin Lambert, Elizabeth Zhang"
date: "Last edited 11/30/21"
output:
  rmdformats::readthedown:
    thumbnails: false
    highlight: "kate"
runtime: shiny
---

```{r setup, include = FALSE}
library(tidyverse)
library(kableExtra) # for example code; delete if not needed
#packages for text analysis shiny app 
library(tidyverse)
library(tidytext)
library(textdata)
library(ggnetwork)
library(igraph)
library(shiny)
library(dplyr)
library(plotly)

# Set code chunk defaults 
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE,
                      warning = FALSE,
                      fig.align = "center")

# Set R environment options
options(knitr.kable.NA = '')
```

![Percy G. Montgomery’s mother, Lee Ester Hunt, holds her medication and pills for various cancer treatments.  (Lee Ester passed away in 2016 - two years after this photograph). Image taken by Giles Clarke in "Cancer Alley", Louisiana, 2014](img/header.jpg)

# Introduction

In Louisiana, a row of toxic waste producing plants has gained national attention. In this area, large corporations continue to release larger and larger amounts of cancer-causing chemicals into the environment, and the effects on community health have been detrimental enough for this area to receive the name "Cancer Alley". The impacts of this unregulated pollution are not equally distributed: the groups at risk are predominantly black and low-income communities. Around the country, industries release fatal amounts of toxic chemicals into our environment, and underprivileged communities are most commonly the victims of these actions. The unequal distribution of wealth and power in our country, created by social systems that protect certain groups and leave others behind, has deep, historically established effects that extend even to the biological level. This is realized in the entangled relationship between sociodemographic inequality in the United States and toxicity in the environment. An individual's place within these imbricated factors is out of their control, and, yet, they can become major determinant's of an individual's health and wellbeing. 

[[CITE LITERATURE AND SPECIFIC INFORMATION ON THESE EFFECTS]]

## Questions

* Are sociodemographic determinants of mortality being acknowledged in the scientific research community?
* What environmental considerations or sociodemographic inequalities exist throughout the US and within individual states? How do they present?
* What relationships, or lack thereof, exist between different sociodemographic variables? How strong are these relationships?
* What’s the distribution of different sociodemographic factors in the US? Is it normal? Is it skewed? If so, in what direction is it skewed?
* What conclusions and implications can we draw from the relationships between certain sociodemographic variables?

# Data

In order to analyze environmental and sociodemographic factors related to mortality rates, we used data from the Environmental Protection Agency (EPA) and the Center for Disease Control (CDC). [[ADD MORE HERE]]

In order to analyze research pertaining to mortality causes, we scraped abstracts from a PubMed search on 10/29/21. Search inputs included "mortality" AND "cause" OR "determinant", and we limited results to only the United States. We unnested individual words from the abstracts, and then we retained only words of interest (e.g. we removed words like "the", "results", or "mortality" which would not provide interesting information, see word options in the network visualization for the full list of retained words).

# Results

<!-- could be interesting to start this section off with a simple but summative scatterplot (doesn't even have to be interactive) that shows overall relationship between mortality (response variable) and predictors of interest, including EQI, income, etc. (choose these based off of which factors are highlighted in our maps) -->

## Interactive map

The below code shows an example of how I used the `geojsonio` package to join our data on factors such as insecticides, income, etc. in order to utilize this data in `SpatialPolygons` for our `leaflet` choropleth map. This required transforming the data within the polygons into a dataframe and joining it with the data from our past csv files, and then transforming it back into polygons. In this example, I am simply adding on another variable "deaths" to the data portion of the Spatial Polygons and then merge that dataframe back into the polygons for use in the map. This was necessary to do for all of our variables I wanted to add into the polygons data.

```{r mapdata-code, echo = TRUE, eval = FALSE}
# show polygon data
library(geojsonio)
counties_all <- geojsonio::geojson_read("leaflet_map_1/counties_map.geojson", what = "sp")
counties_df <- as.data.frame(counties_all)
counties_df <- counties_df %>%
  mutate(deaths = (Total / (population / 100000)))

row.names(counties_df) <- sapply(slot(counties_all, "polygons"), 
                                 function(x) slot(x, "ID"))
counties_all <- SpatialPolygonsDataFrame(counties_all, counties_df)

names(counties_all)
```

Creating a choropleth map within leaflet and Shiny was fairly difficult, and in order to correctly create the colors for every variable in every county, I had to use colorQuantile for palettes and create `pal_colors` and `pal_labs` in order to accurately make a legend that did not just include the percentages. Different bins had to be made for the coal mining data since it did not have enough unique quantiles.

```{r color-code, echo = TRUE, eval = FALSE}
# code to understand color interactivity
counties_all@data$selected <- counties_all@data[, paste(type_choice_names[type_choice_values == input$typevar])]
    
if(input$typevar != "Proportion of Coal Mines") {
      palette <- colorQuantile("RdYlGn", domain = counties_all@data$selected, n = 10)
      counties_all@data$color <- palette(counties_all@data$selected)
      
      pal_colors <- unique(palette(sort(counties_all@data$selected)))
      pal_labs <- quantile(counties_all@data$selected, seq(0, 1, .1), na.rm = T)
      pal_labs <- paste(round(lag(pal_labs), digits = 3), round(pal_labs, digits = 3), sep = " - ")[-1] 
    }
    
    if(input$typevar == "Proportion of Coal Mines") {
      palette <- colorBin("YlOrRd", domain = counties_all@data$selected, 2)
      counties_all@data$color <- palette(counties_all@data$selected)
      pal_colors <- unique(palette(sort(counties_all@data$selected)))
      pal_labs <- c(-Inf, unique(quantile(counties_all@data$selected, na.rm = T)), Inf)
      pal_labs <- paste(round(lag(pal_labs), digits = 3), round(pal_labs, digits = 3), sep = " - ")[-1] 
    }
```

```{r map1-visualization, out.extra='style="border: none;"', fig.cap = "Leaflet Map Visualization with Superfund Sites"}
# embed shiny app once published
 knitr::include_app("https://caitlinlambert.shinyapps.io/leaflet_map_1/?_ga=2.43026016.474256613.1637255347-542459212.1632238530", height = "650px")
```

In the map above, one can locate their county, or any county of interest, and find how that geographical location corresponds to the variables of EQI, median income, mortality rates, insecticide usage, income inequality, percentage of coal mines, and healthcare-related businesses. Some common trends are that there is more income-inequality in urban areas. There are less healthcare-related businesses in rural areas, and more insecticide use in middle America. Coal mining centers around the Appalachian and Rocky Mountains. Superfund sites are actually scattered well across the country, but are more clustered around coastal areas.

```{r hist-super, out.extra='style="border: none;"'}
total_df <- read_csv("final_data.csv")

type_choice_names <- c("ln_hh_inc_x", "Total / (population / 100000)", "eqi_2jan2018_vc", "insecticide_ln_x", "gini_est_x", "std_coal_prim_pop_ln_y","hc_env_rate_ln_x")
type_choice_values <- c("Median Income", "Mortality Rate", "EQI", "Insecticide Applied","Income Inequality", "Proportion of Coal Mines", "Healthcare-related Businesses")
#notes_choice_values <- c("From CDC data, log-transformed", "From CDC data, per 100,000 persons",
#                         "From EPA data, EQI (Environmental Quality Index), 2018 measurement")
names(type_choice_names) <- type_choice_values

shinyApp(
  ######
  #ui
  ######
  
  ui <- fluidPage(
    
    titlePanel("Examining the Effects of Superfund Sites"),
    
    sidebarLayout(
      sidebarPanel(
        selectInput(inputId = "typevar",
                    label = "Choose a variable of interest to plot:",
                    choices = type_choice_values,
                    selected = "EQI")),
      mainPanel(plotOutput(outputId = "plot")))),
  
  server <- function(input, output, session) {
    
    output$plot <- renderPlot({
      ggplot(data=total_df, aes_string(x = type_choice_names[type_choice_values == input$typevar])) + 
          geom_histogram(bins = 20, aes(y = stat(width*density)),
                         color = "darkblue", fill = "lightblue") +
          facet_wrap(~superfund) +
        labs(x = input$typevar,
             y = "Percentage")
    })
  }
)
```

These histograms were created to examine the difference between county environmental and health data for counties that are classified as having Superfund Sites by the EPA and those that are not. For this, I made sure to put the values in percentages rather than count since there are more non-Superfund-Site counties than not, which would skew the results. Some things we can see in these graphs are that the mortality rate for Superfund-Sites are more tightly clustered around their maximum, while non-Superfund-Sites have closer to a normal distribution. However, Superfund Sites appear to have a higher median income and amount of healthcare-related businesses, which may be because Superfund Sites tend to be clustered in highly populated and industrialized areas like cities.

## Relationships by State

For the second visualization, we were interested in looking at a different choropleth map that shows indices of our variables of interests not only nationwide, but also statewide. For this visualization, we were interested in giving users the choice to explore these relationships closer at the state level, and a person can even zoom into the choropleth map above and view both visualizations side by side. In order to aid this, users are able to view a scatter plot and a density plot of their variable of interest for all the counties in their state of interest. This can help highlight inequalities within their state and users are further able to view their counties of interest on the scatter plots and examine them relative to others in the state. 

The click-hover-brush feature allows users to see values of a specific county in the scatter plot and a specific position on the plot of the density plot. Here is the code that I used to allow users to look closer at counties or points selected on the scatter plot. They can select counties of interest from the selectize input function. 

```{r hover code, echo = TRUE, eval = FALSE}
# Created Function for Hover/ Click Interactivity 
  output$scatter_info <- renderText({
    xy_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("x=", round(e$x, 1), " y=", round(e$y, 1), "\n")
    }
    xy_range_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("xmin=", round(e$xmin, 1), " xmax=", round(e$xmax, 1), 
             "ymin=", round(e$ymin, 1), " ymax=", round(e$ymax, 1))
    }
    
    paste0(
      "click: ", xy_str(input$plot_click),
      "dblclick: ", xy_str(input$plot_dblclick),
      "hover: ", xy_str(input$plot_hover),
      "brush: ", xy_range_str(input$plot_brush)
    )
  })
```

I used a similar function for the density plot and used the `plotly` package to enable hover interactivity for the map.

Here is the embedded shiny app. The entire US is currently selected, but users have the choice to view a specific state. Click on the map to view values for each county.

### Interactive Map and Associated Plots

```{r interactive-map-plots}
#Load necessary packages
library(shiny)
library(shinythemes)
library(tidyverse)
library(DT)
library(urbnmapr)
library(ggplot2)
library(RColorBrewer)
library(ggiraph)
library(naniar)
library(sf)
library(leaflet)
library(dplyr)
library(geojsonio)
library(maptools)
library(tmap)

# Import data on variables of interest as well as county geography
county_data <- read_csv("interactive_state_app/county_data.csv")
scatter_data <- read_csv("interactive_state_app/scatter_data.csv")

# Create choices for states of interest
statenames <- read_csv("interactive_state_app/states.csv") %>% 
  janitor::clean_names()

state_choice_values <- c("ALL", unique(statenames$state))

# Create choices for variables of interest
var_choice_values <- c("total_deaths", "carbon_monoxide", "particulate_matter", 
                       "vice_businesses", "education_businesses", "service_agencies", 
                       "healthcare_businesses", "commute_time", "fungicide", 
                       "herbicide", "insecticide", "pct_unemp_total", "pct_poverty", 
                       "gini_coefficient")
var_choice_names <- c("Total Deaths", "Carbon Monoxide", "Particulate Matter", 
                      "Vice-Related Businesses", "Education-Related Businesses", 
                      "Service Agencies", "Healthcare-Related Businesses", 
                      "Commute Time", "Fungicides Applied", "Herbicides Applied",
                      "Insecticides Applied", "Percent Unemployed", 
                      "Percent in Poverty",
                      "Income Inequality")
names(var_choice_values) <- var_choice_names

# For button through which users can customize distinguishing variables by color
color_choice_values <- c("superfund")
color_choice_names <- c("National Priority Sites")
names(color_choice_values) <- color_choice_names

# Selectize counties
county_choices <- unique(scatter_data$county)


shinyApp(
  ############
#    ui    #
############
ui <- fluidPage(
  
  titlePanel("Interactive Map by State"),
  
  sidebarLayout(
    sidebarPanel(
      # Choose variables of interest
      selectInput(inputId = "index",
                  label = "Choose environmental index of choice:",
                  choices = var_choice_values,
                  selected = "fungicide"),
      
      # Choose states of interest to display
      selectInput(inputId = "state",
                  label = "Choose a state of interest:",
                  choices = state_choice_values,
                  selected = "Texas"),
      
      # Choose to color points by presence of a super fund site or not
      radioButtons(inputId = "pt_color",
                   label = "Line graphs are colored by:",
                   choices = color_choice_values,
                   selected = NULL),
      
      # Choose to view counties of interest in selected states
      selectizeInput(inputId = "county_name",
                     label = "Identify counties of interest in scatter plot:",
                     choices = NULL,
                     selected = NULL,
                     multiple = TRUE)
    ),
    
    mainPanel(plotlyOutput(outputId = "mapvar"),
              splitLayout(cellwidths = c("50%", "50%"), 
                          plotOutput(outputId = "scatter",
                                     click = "plot_click",
                                     dblclick = "plot_dblclick",
                                     hover = "plot_hover",
                                     brush = "plot_brush"
                          ),
                          plotOutput(outputId = "density",
                                     click = "density_click",
                                     dblclick = "density_dblclick",
                                     hover = "density_hover",
                                     brush = "density_brush")
              ),
              splitLayout(cellWidths = c("50%", "50%"),
                          verbatimTextOutput("scatter_info"),
                          verbatimTextOutput("density_info"))
              
              
    )
  )
),


############
# server   #
############
server <- function(input, output) {
  
  # Create data for map reacting to state filter
  
  data_for_map <- reactive({
    data <- {if (input$state != "ALL") 
      filter(county_data, county_data$state_name == input$state)
      else county_data}
  })
  
  # Create Interactive Map
  
  output$mapvar <- renderPlotly({
  m <-  ggplot(data = data_for_map(), mapping = aes_string(x = "long", 
                                                       y = "lat", 
                                                       group = "group", 
                                                       fill = input$index)) +
      layer(data = data_for_map(), 
            geom = "polygon", stat = "identity", position = "identity") +
      geom_polygon(color = NA) +
      scale_fill_gradientn(colours = heat.colors(10)) +
      coord_map(projection = "albers", lat0 = 39, lat1 = 45) +
      theme(legend.position="bottom") +
      labs(x = "longitude",
           y = "latitude",
           fill = var_choice_names[var_choice_values == input$index],
           title = paste(var_choice_names[var_choice_values == input$index], 
                         "For ",
                         input$state)) +
      theme(panel.background = element_rect("black"))
  
  ggplotly(m)
  
  })
  
  # Create data for scatter plot reacting to filters
  # Will use this same reactive data set for density plot
  
  data_for_scatter <- reactive({
    if (input$state != "ALL") 
      filter(scatter_data, 
             scatter_data$state_name == input$state, 
             scatter_data$environ_characteristic == input$index)
    else filter (scatter_data, environ_characteristic %in% input$index)
  })
  
  observeEvent(data_for_scatter(), {
    county_state_choices <- unique(data_for_scatter()$county)
    updateSelectizeInput(inputId = "county_name", 
                         choices = county_state_choices, 
                         selected = NULL) 
  })
  
  # Create Interactive Scatter Plots 
  
  output$scatter <- renderPlot({
    ggplot(data = data_for_scatter(), aes_string(x = "median_income", y = "value", 
                                                 color = "superfund")) +
      geom_point(position = "jitter") +
      labs(x = "Median County Income",
           y = "Index Value",
           title = paste(var_choice_names[var_choice_values == input$index], 
                         "By Median Income"),
           subtitle = paste("For ", input$state),
           caption = "Colored by National Priority Sites.
                      Data is collected from counties in the US. 
                      Refer to EQI website for a dictionary on the variables.",
           color = color_choice_names[color_choice_values]) +
      geom_label(data = filter(data_for_scatter(),
                               county %in% input$county_name),
                 aes(label = county), 
                 show.legend = FALSE
      ) +
      theme(legend.position = "bottom",
            plot.title.position = "plot",
            panel.grid = element_line(FALSE),
            panel.background = element_rect(fill = "black")) 
  })
  
  # Create Hover/ Click Interactivity for Scatter Plot 
  
  output$scatter_info <- renderText({
    xy_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("x=", round(e$x, 1), " y=", round(e$y, 1), "\n")
    }
    xy_range_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("xmin=", round(e$xmin, 1), " xmax=", round(e$xmax, 1), 
             "ymin=", round(e$ymin, 1), " ymax=", round(e$ymax, 1))
    }
    
    paste0(
      "click: ", xy_str(input$plot_click),
      "dblclick: ", xy_str(input$plot_dblclick),
      "hover: ", xy_str(input$plot_hover),
      "brush: ", xy_range_str(input$plot_brush)
    )
  })
  
  
  # Create Interactive Density Plots
  
  output$density <- renderPlot({
    ggplot(data = data_for_scatter(), aes_string(x = "value")) +
      geom_density(fill = "red", alpha = 0.8) +
      #geom_vline(xintercept = mean("value"), color = "black") +
      labs(x = paste(var_choice_names[var_choice_values == input$index]),
           y = "Density",
           title = paste("Density Plot of ", 
                         var_choice_names[var_choice_values == input$index]),
           subtitle = paste("For ", input$state),
           caption = "Data is collected from counties in the US. 
           Refer to EQI website for a dictionary on the variables.") +
      theme(plot.title.position = "plot",
            panel.grid = element_line(FALSE),
            panel.background = element_rect("black"))
  })
  
  # Create Hover/ Click Interactivity for Density Plot
  
  output$density_info <- renderText({
    xy_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("x=", round(e$x, 1), " y=", round(e$y, 1), "\n")
    }
    xy_range_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("xmin=", round(e$xmin, 1), " xmax=", round(e$xmax, 1), 
             "ymin=", round(e$ymin, 1), " ymax=", round(e$ymax, 1))
    }
    
    paste0(
      "click: ", xy_str(input$density_click),
      "dblclick: ", xy_str(input$density_dblclick),
      "hover: ", xy_str(input$density_hover),
      "brush: ", xy_range_str(input$density_brush)
    )
  })
},
options = list(height = 1000)
)
```

It’s visible that there is inequality and different environmental considerations throughout the United States. In looking at a map of the entire country or zooming in to a specific state, it’s visible that the value of the variables vary and there are areas that report higher or lower values for specific indices. For example, there are disproportionately more coal mines in mountainous areas and higher insecticide use in rural areas. Additionally, there is a visible rural-urban divide with regard to income level and income equality. 

Ultimately, it’s hard to quantify all the results that we can obtain from this visualization -- each state is different and there are many factors that may account for these differences. Essentially, the purpose of this visualization is to give a user the power to explore the data used to create this application and use that to inform their individual questions and draw their conclusions.

## Inter-Variable Relationships

Further than just looking at the distribution of variables of interest nationwide and statewide, we were further interested in looking at inter-variable relationships and allowing users to explore relationships of interest. To aid this, I created 2 additional Shiny apps: an interactive line graph and an interactive app that produces a simple linear regression output for any 2 variables of interest.

### Interactive Line Graphs

The interactive line graph allows users to view the relationship between 2 indexes of choice through a smooth curve. They also have the option to distinguish the data by color depending on whether counties are national priority sites. They can explore as many relationships as they choose. I used the `plotly` package to further allow users to hover over the line and view the value at a specific position on the plot. As opposed to the scatterplot in the shiny app above which has a fixed x-axis of median income, this app allows users all the flexibility. Here is the embedded Shiny app:


```{r interactive-line-graph}
# #Load packages 
# library(shiny)
# library(shinythemes)
# library(tidyverse)
# library(DT)
# library(ggplot2)
# library(RColorBrewer)
# library(ggiraph)
# library(naniar)
# library(dplyr)
# library(plotly)
# 
# # Import data on variables of interest
# county_data <- read_csv("interactive_state_app/county_data.csv")
# 
# # Create choices for variables of interest
# linevar_choice_values <- c("total_deaths", "carbon_monoxide", "particulate_matter", 
#                            "vice_businesses", "education_businesses", "service_agencies", 
#                            "healthcare_businesses", "commute_time", "fungicide", 
#                            "herbicide", "insecticide", "pct_unemp_total", "pct_poverty", 
#                            "gini_coefficient", "ln_hh_inc_x", "eqi_2jan2018_vc")
# linevar_choice_names <- c("Total Deaths", "Carbon Monoxide", "Particulate Matter", 
#                           "Vice-Related Businesses", "Education-Related Businesses", 
#                           "Service Agencies", "Healthcare-Related Businesses", 
#                           "Commute Time", "Fungicides Applied", "Herbicides Applied",
#                           "Insecticides Applied", "Percent Unemployed", 
#                           "Percent in Poverty",
#                           "Income Inequality", "Median Income", "EQI")
# names(linevar_choice_values) <- linevar_choice_names
# 
# 
# shinyApp(
#   ############
# #    ui    #
# ############
# ui <- fluidPage(
#   
#   titlePanel("Line Graphs of Variables of Interest"),
#   
#   sidebarLayout(
#     sidebarPanel(
#       # Choose variable 1 of interest
#       selectInput(inputId = "index1",
#                   label = "Choose index 1 of choice (x-axis):",
#                   choices = linevar_choice_values,
#                   selected = "fungicide"),
#       
#       # Choose variable 2 of interest
#       selectInput(inputId = "index2",
#                   label = "Choose index 2 of choice (y-axis):",
#                   choices = linevar_choice_values,
#                   selected = "total_deaths")
#       
#     ),
#     
#     mainPanel(plotlyOutput(outputId = "linegraph"))
#     
#   )
# ),
# 
# ############
# # server   #
# ############
# server <- function(input, output) {
#   
#   output$linegraph <- renderPlotly({
#     
#     p <- ggplot(data = county_data, aes_string(x = input$index1, y = input$index2)) +
#       geom_smooth(methods = "loess") +
#       labs(x = linevar_choice_names[linevar_choice_values == input$index1],
#            y = linevar_choice_names[linevar_choice_values == input$index2],
#            title = paste(linevar_choice_names[linevar_choice_values == input$index2], 
#                          "by",
#                          linevar_choice_names[linevar_choice_values == input$index1]),
#            caption = "Data is collected from counties in the US.
#               Refer to EQI website for a dictionary on the variables.") +
#       theme(legend.position = "bottom",
#             plot.title.position = "plot",
#             panel.background = element_rect(fill = "black"))
#     
#     ggplotly(p)
#   })
#   
#   
# },
# 
# options = list(height = 500)
# 
# )

```

```{r interactive-line-graph-color}
# Load packages 
library(shiny)
library(shinythemes)
library(tidyverse)
library(DT)
library(ggplot2)
library(RColorBrewer)
library(ggiraph)
library(naniar)
library(dplyr)
library(plotly)

# Create choices for variables of interest
linevar_choice_values <- c("total_deaths", "carbon_monoxide", "particulate_matter", 
                           "vice_businesses", "education_businesses", "service_agencies", 
                           "healthcare_businesses", "commute_time", "fungicide", 
                           "herbicide", "insecticide", "pct_unemp_total", "pct_poverty", 
                           "gini_coefficient", "ln_hh_inc_x", "eqi_2jan2018_vc")
linevar_choice_names <- c("Total Deaths", "Carbon Monoxide", "Particulate Matter", 
                          "Vice-Related Businesses", "Education-Related Businesses", 
                          "Service Agencies", "Healthcare-Related Businesses", 
                          "Commute Time", "Fungicides Applied", "Herbicides Applied",
                          "Insecticides Applied", "Percent Unemployed", 
                          "Percent in Poverty",
                          "Income Inequality", "Median Income", "EQI")
names(linevar_choice_values) <- linevar_choice_names

# For label to distinguish variables by color
linecolor_choice_values <- c("superfund", "na")
linecolor_choice_names <- c("National Priority Sites", "Not colored")
names(linecolor_choice_values) <- linecolor_choice_names


shinyApp(
  ############
#    ui    #
############
ui <- fluidPage(
  
  titlePanel("Line Graphs of Variables Colored by National Priority Sites"),
  
  sidebarLayout(
    sidebarPanel(
      # Choose variable 1 of interest
      selectInput(inputId = "index1",
                  label = "Choose index 1 of choice (x-axis):",
                  choices = linevar_choice_values,
                  selected = "fungicide"),
      
      # Choose variable 2 of interest
      selectInput(inputId = "index2",
                  label = "Choose index 2 of choice (y-axis):",
                  choices = linevar_choice_values,
                  selected = "total_deaths"),
      
      radioButtons(inputId = "pt_color",
                   label = "Color line graphs by:",
                   choices = linecolor_choice_values,
                   selected = NULL)
      
    ),
    
    mainPanel(plotlyOutput(outputId = "linegraphcolor"))
    
  )
),

############
# server   #
############


server <- function(input, output) {
  
  
  
  output$linegraphcolor <- renderPlotly({
   q <- ggplot(data = county_data, aes_string(x = input$index1, y = input$index2, 
                                    color = ifelse(
                                      input$pt_color == "superfund", 
                                      "superfund", FALSE)))+
          geom_smooth(methods = "loess") +
          labs(x = linevar_choice_names[linevar_choice_values == input$index1],
              y = linevar_choice_names[linevar_choice_values == input$index2],
              title = paste(linevar_choice_names[linevar_choice_values == input$index2], 
                            "by",
                            linevar_choice_names[linevar_choice_values == input$index1]),
              caption = "Data is collected from counties in the US. 
              Refer to EQI website for a dictionary on the variables.",
              color = "National Priority Sites") +
          theme(legend.position = "bottom",
                plot.title.position = "plot",
                panel.background = element_rect(fill = "black"))
   
   ggplotly(q) %>%
     layout(legend = list(x = 0.1, y = 0.9))
   
  })
},

options = list(height = 500)

)
```

Just like in the previous Shiny app, there are many insights that can be drawn from interacting with the app. We can look at one conclusion in-depth. At the moment, fungicide application and total deaths is selected and it’s interesting to see how the total number of deaths appears to increase as the amount of fungicides applied. The total number of deaths seem to increase much faster depending on the amount of fungicide applied for counties that are national priority sites. The entire line graph is also higher for these counties. This suggests that there may be many other factors at play at the sites, given that they are flagged as having higher toxicological levels, that may work together to exacerbate the effects of fungicide applied on total deaths and make populations in these counties more vulnerable. 

### Interactive Simple Linear Regression 

Lastly, to further allow users to explore bivariate relationships in much further depth, I created a Shiny application that runs a linear regression model on any 2 variables of interest. The application reactively takes in any 2 variables of interest, fits a simple linear regression model, produces the summary output and a linear model plot, pulls out important statistical values such as the adjusted r-squared and the p-value, and then interprets the results on behalf of the user. The reactive linear model function that I used is as follows:

```{r lm-function, echo = TRUE, eval = FALSE}
# Create reactive linear model formula
  lm1 <- reactive({
    lm(reformulate(input$predictor, input$response), data = county_data)
    })
```

In order to achieve this, I used the `MathJax` package in R in multiple ways. Here is an example of how I used the package to pull out important statistical results:

```{r mathjax, echo = TRUE, eval = FALSE}
 # Pull out and print results from SLR output
  output$results <- renderUI({
    withMathJax(
      paste0(
        "Adj. \\( R^2 = \\) ", round(summary(lm1())$adj.r.squared, 3),
        ", \\( \\beta_0 = \\) ", round(lm1()$coef[[1]], 3),
        ", \\( \\beta_1 = \\) ", round(lm1()$coef[[2]], 3),
        ", P-value ", "\\( = \\) ", signif(summary(lm1())$coef[2, 4], 3)
      )
    )
  })
```

Users are warned to check diagnostic conditions for linear models before drawing final conclusions. Because the primary purpose of the app is not to run statistical analyses on all the variables, that output is not provided for users. Ultimately, the purpose of the app is to fit simple linear models and allow users to see which variables are strongly correlated and explore what that might mean:

```{r slr}
# Load packages 
library(shiny)
library(shinythemes)
library(tidyverse)
library(DT)
library(ggplot2)
library(RColorBrewer)
library(ggiraph)
library(naniar)
library(dplyr)
library(mosaic)
library(plotly)
library(rmarkdown)
library(knitr)
library(pander)
library(mathjaxr)

# Create choices for variables of interest
slrvar_choice_values <- c("total_deaths", "carbon_monoxide", "particulate_matter", 
                           "vice_businesses", "education_businesses", "service_agencies", 
                           "healthcare_businesses", "commute_time", "fungicide", 
                           "herbicide", "insecticide", "pct_unemp_total", "pct_poverty", 
                           "gini_coefficient")
slrvar_choice_names <- c("Total Deaths", "Carbon Monoxide", "Particulate Matter", 
                          "Vice-Related Businesses", "Education-Related Businesses", 
                          "Service Agencies", "Healthcare-Related Businesses", 
                          "Commute Time", "Fungicides Applied", "Herbicides Applied",
                          "Insecticides Applied", "Percent Unemployed", 
                          "Percent in Poverty",
                          "Income Inequality")
names(slrvar_choice_values) <- slrvar_choice_names

shinyApp(
  ############
#    ui    #
############
ui <- fluidPage(
  
  titlePanel("Simple Linear Regression of 2 Variables of Interest"),
  
  sidebarLayout(
    sidebarPanel(
      # Choose variable 1 of interest
      selectInput(inputId = "predictor",
                  label = "Choose predictor variable of choice (x-axis):",
                  choices = slrvar_choice_values,
                  selected = "fungicide"),
      
      # Choose variable 2 of interest
      selectInput(inputId = "response",
                  label = "Choose response variable of choice (y-axis):",
                  choices = slrvar_choice_values,
                  selected = "total_deaths")
      
    ),
    
    mainPanel(
      tags$b("Compute parameters in R:"),
      verbatimTextOutput("summary"),
      br(),
      br(),
      tags$b("Regression plot:"),
      uiOutput(outputId = "results"),
      plotlyOutput(outputId = "regression"),
      br(),
      br(),
      tags$b("Interpretation:"),
      uiOutput(outputId = "interpretation")
      )
    
  )
),

############
# server   #
############
server <- function(input, output) {
  
  # Create reactive linear model formula
  lm1 <- reactive({
    lm(reformulate(input$predictor, input$response), data = county_data)
    })
  
  # Create summary output of a simple linear regression
  output$summary <- renderPrint({summary(lm1())})
  
  # Pull out and print results from SLR output
  output$results <- renderUI({
    withMathJax(
      paste0(
        "Adj. \\( R^2 = \\) ", round(summary(lm1())$adj.r.squared, 3),
        ", \\( \\beta_0 = \\) ", round(lm1()$coef[[1]], 3),
        ", \\( \\beta_1 = \\) ", round(lm1()$coef[[2]], 3),
        ", P-value ", "\\( = \\) ", signif(summary(lm1())$coef[2, 4], 3)
      )
    )
  })
  
  # Generate regression plot
  output$regression <- renderPlotly({
    r <- ggplot(county_data, aes_string(x = input$predictor, y = input$response)) +
      stat_smooth(method = "lm", se = TRUE) +
      ylab(slrvar_choice_names[slrvar_choice_values == input$response]) +
      xlab(slrvar_choice_names[slrvar_choice_values == input$predictor]) +
      theme_minimal()
    
    ggplotly(r)
  }) 
  
  # Draw conclusions and print out interpretation
  output$interpretation <- renderUI({
    if (summary(lm1())$coefficients[1, 4] < 0.05 & 
        summary(lm1())$coefficients[2, 4] < 0.05) {
      withMathJax(
        paste0("*Make sure the assumptions for linear regression (independance, 
               linearity, normality and homoscedasticity) are met before 
               interpreting the coefficients."),
        br(),
        br(),
        paste0("For a (hypothetical) value of ", input$predictor, 
               " = 0, the mean of ", input$response, " = ", 
               round(lm1()$coef[[1]], 3), "."),
        br(),
        br(),
        paste0("For an increase of one unit of ", input$predictor, ", ", 
               input$response, ifelse(round(lm1()$coef[[2]], 3) >= 0, 
                                      " increases (on average) by ", 
                                      " decreases (on average) by "), 
               abs(round(lm1()$coef[[2]], 3)), ifelse(abs(round(lm1()$coef[[2]], 3)) >= 2, 
                                                      " units", " unit"), ".")
      )
    } else if (summary(lm1())$coefficients[1, 4] < 0.05 & 
               summary(lm1())$coefficients[2, 4] >= 0.05) {
      withMathJax(
        paste0("*Make sure the assumptions for linear regression (independance, 
               linearity, normality and homoscedasticity) are met before 
               interpreting the coefficients."),
        br(),
        br(),
        paste0("For a (hypothetical) value of ", input$predictor, " = 0, 
               the mean of ", input$response, " = ", round(lm1()$coef[[1]], 3), "."),
        br(),
        br(),
        paste0("\\( \\beta_1 \\)", " is not significantly different from 0 (p-value = ", 
               round(summary(lm1())$coefficients[2, 4], 3), ") so there is no significant 
               relationship between ", input$predictor, " and ", input$response, ".")
      )
    } else if (summary(fit)$coefficients[1, 4] >= 0.05 & summary(fit)$coefficients[2, 4] < 0.05) {
      withMathJax(
        paste0("*Make sure the assumptions for linear regression (independance, 
               linearity, normality and homoscedasticity) are met before 
               interpreting the coefficients."),
        br(),
        br(),
        paste0("\\( \\beta_0 \\)", " is not significantly different from 0 (p-value = ", 
               round(summary(lm1())$coefficients[1, 4], 3), ") so when ", input$predictor, 
               " = 0, the mean of ", input$response, " is not significantly different from 0."),
        br(),
        br(),
        paste0("For an increase of one unit of ", input$predictor, ", ", 
               input$response, ifelse(round(lm1()$coef[[2]], 3) >= 0, 
                                      " increases (on average) by ", 
                                      " decreases (on average) by "), 
               abs(round(lm1()$coef[[2]], 3)), ifelse(abs(round(lm1()$coef[[2]], 3)) >= 2,
                                                      " units", " unit"), ".")
      )
    } else {
      withMathJax(
        paste0("*Make sure the assumptions for linear regression (independance, 
               linearity, normality and homoscedasticity) are met before 
               interpreting the coefficients."),
        br(),
        br(),
        paste0("\\( \\beta_0 \\)", " and ", "\\( \\beta_1 \\)", " are not 
               significantly different from 0 (p-values = ", 
               round(summary(lm1())$coefficients[1, 4], 3), " and ", 
               round(summary(lm1())$coefficients[2, 4], 3), 
               ", respectively) so the mean of ", input$response, 
               " is not significantly different from 0.")
      )
    }
  })
  
},
options = list(height = 1200)
)
```

Just like in the previous Shiny app, there are many insights that can be drawn from interacting with the app and the purpose of creating the interactivity is to allow users to make those conclusions and grapple with the implications themselves. However, we can look at the same relationship we examined on the linear graphs: fungicide application as a predictor for total deaths. From the output, we can see that the adjusted R-squared is quite low at 0.019, suggesting that the variance in total deaths explained by fungicides applied is very low. This makes sense as there are many factors interacting to explain death rate. However, what’s more striking is the strong correlation between the 2 variables, and a t-test for slope yields a p-value of 0. In looking back at the interactive map, we see that fungicide application is not evenly distributed throughout the US and is more in the west coast, parts of the mid-west, and Florida. Even within states, there are certain counties that have higher fungicide application, and one can look at the first map to determine whether those areas are national priority sites or not. This highlights the inequality and/ or different environmental considerations that exist when it comes to fungicide use in different geographic locations in the US. In knowing the strong relationship between fungicide application and total deaths, this has huge implications and leads to further questions such as what predisposes certain areas to higher fungicide application versus others?

Ultimately, this is just one question resulting from one bivariate analysis, but there are many such questions and considerations that a user can explore using this application.


## Word counts in research abstracts {.tabset .tabset-fade .tabset-pills}

### Animated bar chart

![](data/gganim2.gif)

In the above animation, the top 10 words up until 2011 do not contain the word "social". In 2011, though, "social" enters the top ten words, and its ranking increases until 2021, when it is the most used word in research abstracts.

### Code

The below code demonstrates how we used the `gganimate`, which builds off of the `ggplot2` package, and `gifski` packages to create an animated bar chart of top words used in abstracts over time. We used the `gganimate` package to create an animated object from `barchart`, which was a static barchart of top words that we created using `ggplot2`. We used the `gifski` package to render a gif from out animation. 

```{r barchart-code, echo = TRUE, eval = FALSE}
#create animated object from ggplot barchart
anim <- barchart +
  #transition by publication_year
  transition_states(publication_year, 
                    transition_length = 8, state_length = 4, wrap = FALSE) +
  view_follow(fixed_x = TRUE) + #x scale should be animated and modified by the view
  ease_aes('sine-in-out') + #smooth out animations
  
#create gif
animate(anim, #object to create gif
        500, #sets length in seconds
        fps = 20, #defines frames per second
        width = 900, height = 750, #sets dimensions
        renderer = gifski_renderer("data/gganim2.gif"), #renders and saves gif
        end_pause = 15, start_pause =  15 #length of pauses between repeats) 
```

## Word networks in research abstracts {.tabset .tabset-fade .tabset-pills}

### Interactive network

```{r network-display2, out.extra='style="border: none;"', out.width='56%'}
#read in list of abstracts
abstract_words <- read_csv("data/abstract_words.csv") 

#set seed and theme
set.seed(83426)
theme_set(theme_classic())

######
#data wrangling
######


empty <- data.frame(word = character())
keep_words <- empty %>%
  add_row(word = c("mortality", "disease", "age", "cancer", "women", "population", "hiv", "social",
                   "clinical", "children", "infection", "protein", "genetic", "blood",
                   "cardiovascular", "community", "diabetes", "heart", "exposure",
                   "gene", "national", "drug", "chronic", "physical", "virus",
                   "hospital", "sex", "smoking", "therapy", "interventions", "white",
                   "genes", "family", "race", "weight", "education", "alcohol",
                   "breast", "maternal", "antibodies", "lung", "income", "disparities",
                   "environmental", "obesity", "tumor", "region", "african", "stroke",
                   "cardiac", "viral", "hypertension", "immune", "respiratory", "hispanic",
                   "food", "infections", "dna", "infant", "gender", "socioeconomic",
                   "history", "coronary", "racial", "demographic", "mental", "male",
                   "underlying", "child", "infants", "poor", "ethnic", "rural",
                   "antibody", "pulmonary", "renal", "policy", "efforts", "female",
                   "sexual", "depression", "behavioral", "influenza", "economic", "genome",
                   "urban", "ethnicity"))

interest_words <- empty %>%
  add_row(word = c("mortality", "social", "disparities", "cancer", "community",
                   "genetic", "environmental", "family",
                   "racial", "demographic", "economic", "exposure")) %>% 
  mutate(category = NA)
interest_words$category[interest_words$word %in% c("mortality", "cancer")] <- "mortality"
interest_words$category[interest_words$word %in% c("social", "disparities", "racial", "demographic", 
                                    "economic")] <- "sociodemographic"
interest_words$category[interest_words$word %in% c("community", "family")] <- "contextual"
interest_words$category[interest_words$word %in% c("genetic")] <- "genetic"
interest_words$category[interest_words$word %in% c("environmental", "exposure")] <- "exposure"

shinyApp(
######
#ui
######

ui <- fluidPage(
  
  # tabPanel(
    titlePanel("Words used in research abstracts exploring causes of mortality"),

    sidebarLayout(
      sidebarPanel(
        sliderInput("year_b", "Year:",
                   min = 1985, max = 2021, sep= "",
                   value = 2006), 
        selectizeInput(inputId = "interest_list", 
                       label = "Select words to include:", 
                       choices = keep_words$word, 
                       selected = interest_words$word,
                       multiple = TRUE
        )
      ),
      mainPanel(plotOutput(outputId = "network"))
    # )
  )
), 

######
#server
######

server <- function(input, output) {
  
  #words of interest not found in year
  interest_missing <- reactive({
    present <- abstract_words %>% 
      filter(publication_year == input$year_b) 
    missing <- setdiff(as.list(input$interest_list), as.list(present$word))
    if(length(missing) > 0) {data <- paste(missing, collapse = ", ")}
    else {data <- "NA"}
  })
  
  #network
  output$network <- renderPlot({
    set.seed(83426)
    #choose interest words from year
    network_words <- abstract_words %>% 
      filter(publication_year == input$year_b) %>% 
      filter(word %in% input$interest_list) %>% 
      count(word, sort = TRUE) %>%  #get counts of words  
      left_join(interest_words, by = "word")
    #create dataframe
    df <- abstract_words %>%
      filter(publication_year == input$year_b) %>% 
      right_join(network_words, by = "word") %>% #only keeps interest words
      unique() %>% #remove repeats of connections in same abstract
        select(pmid, word) %>%
        table() %>%
        crossprod() #creates co-occurence matrix
    diag(df) <- 0 #sets connections between same word to 0
    df <- as.data.frame(df) 
    
    num_word <- ncol(df) 

    #define vertices and edges
    ve <- network_words 
    ed <- df %>%
      mutate(from = rownames(.)) %>%
      tidyr::gather(to, weight, 1:num_word) %>% #gathers co-instances from matrix
      mutate(weight = ifelse(weight == 0, NA, weight))

    #create igraph
    abst_igraph <- graph_from_data_frame(d = ed,
                                         vertices = ve,
                                         directed = FALSE) %>%
      simplify() #remove duplicate edges

    #plot network
    abst_network <- ggnetwork(abst_igraph)
    ggplot(data = abst_network, aes(x = x, y = y,
                                   xend = xend, yend = yend)) +
      geom_edges(aes(size = weight, 
                     alpha = ifelse(category == "sociodemographic", 
                                    "Connected", "Not Connected")), 
                 color = "gray", 
                 curvature = .1) +
      geom_nodes(aes(size = n, color = category), shape = 20)  +
      geom_nodetext_repel(aes(label = name, size = n), 
                    point.padding = unit(0.2, "lines"), color = "gray10") +
      colorspace::scale_color_discrete_qualitative(palette = "Dark 3") +
      guides(size = guide_legend(order = 2), color = guide_legend(order = 1), 
             fill = guide_legend(order = 3)) +
      ggraph::scale_edge_width(c(0.5, 5)) +
      scale_alpha_discrete(range = c(1, 0.5)) +
      theme_blank() +
      labs(size = "Number", color = "Category", alpha = "Sociodemographic?", 
           caption = paste("Words not found: ", interest_missing(), 
                           "\n Data source: PubMed, years before 1985 ommitted due to insufficient data"))

  })
}, 
options = list(height = 600)
)

```

In the above network, sociodemographic factors tend to be on the edge of the network in earlier years, and the networks tend to be more disconnected. As the years progress, though, at around 2010-2013, the network tend to become much more connected. From 2013-2021, sociodemographic factors also tend to become more and more central to the network. 

### Code

To create a list of connections between words and how often those connections occured, we created a co-occurence matrix of words individual abstract. The below code demonstrates how we prepared our data from `abstract_words`, which was a dataframe which contained a column with the unique identifier for each abstract, the year that abstract was published in, and a word of interest from that abstract.  

```{r network-code, echo = TRUE, eval = FALSE}
#create dataframe with co-occurence matrix
df <- abstract_words %>%
  #keeps only year of interest based off of input from user in Shiny
  filter(publication_year == input$year_b) %>% 
  right_join(network_words, by = "word") %>% #only keeps interest words
  unique() %>% #remove repeats of connections in same abstract
  select(pmid, word) %>%
  table() %>% 
  crossprod() #creates co-occurence matrix of connections 
diag(df) <- 0 #sets connections between same word to 0
df <- as.data.frame(df)

#define edges from co-occurence matrix
ed <- df %>%
  mutate(from = rownames(.)) %>% #create "from" column from row names 
  #gathers co-occurences from matrix,
    #create "to" column from column names, 
    #create "weight" column from number of co-occurences
  tidyr::gather(to, weight, 1:ncol(df)) %>% 
  mutate(weight = ifelse(weight == 0, NA, weight)) #weights of 0 to NA
```

# Conclusion

The recent significant increase in the word "social" in research abstracts suggests that sociodemographic determinants are being increasingly acknowledged in the scientific research community. The recent increase in connectedness of sociodemographic words in abstracts also suggests these determinants are increasingly included in the majority of the body of mortality research. These findings are promising; slowly, the rampant inequality in health outcomes around the United States is becoming acknowledged in research communication. 

## Limitations and Future Directions

Our findings on the focus of research over time is promising. The rise in the consideration of social factors and their connection to mortality shows increased acknowledgement of the inequality of mortality risks. However, the gap between research and policy is often wide and difficult to bridge. Progressive findings in scientific abstracts, while representative of the inclusion of social thought into clinical work, are not an accurate measure of whether tangible change is being generated from these conclusions. Through lobbying, corporations have a much larger influence in restricting the passage of policies that may reduce their profits than in research (though the influence on scientific research is still present, through funding sources). To assess whether policy makers are putting forth legislation that addresses the root sociodemographic causes of unequal mortality risk, and whether that inequality is even acknowledged in the first place, we would like to  extend our project in the future by analyzing legislation that is proposed/passed in regards to environmental toxicity and mortality. This can allow us to understand whether there is a lag between research and legislation and to explore how the government is addressing health inequalities. 

# References

<!-- beginning of template -->

# Header 1 (Section heading)

## Header 2 (Subsection heading)

### Header 3 (Subsubsection heading)

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For example, you can include **Bold** and _Italic_ and `Code` text.  For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

You should test out updating your GitHub Pages website:

* clone your group's blog project repo in RStudio
* update "Your Project Title Here" to a new title in the YAML header
* knit `index.Rmd` (we will now knit to HTML by default instead of pdf)
* commit and push **both** `index.Rmd` and `index.html`
* go to https://stat231-f21.github.io/blog_five-chives/ to see the published test document (this is publicly available!)

## Including code and plots

You can embed code as normal, for example:

```{r cars}
summary(cars)
```

Let's clean up the format of that output instead of using the standard R output:

```{r pretty-table, echo = TRUE}
summary(cars) %>%
  kable(col.names = c("Speed", "Distance"),
        row.names = FALSE) %>%
  kable_styling(bootstrap_options = "striped",
                full_width = FALSE) %>%
  row_spec(0, bold = TRUE) %>%
  column_spec(1:2, width = "1.5in") 
```

In a study from the 1920s, fifty cars were used to see how the speed of the car and the distance taken to stop were related.  Speeds ranged between `r min(cars$speed)` and `r max(cars$speed)` mph.  Distances taken to stop ranged between `r min(cars$dist)` and `r max(cars$dist)` feet, with the middle 50% falling between `r as.numeric(quantile(cars$dist)[2])` and `r as.numeric(quantile(cars$dist)[4])` feet.  

You can also embed plots as normal, for example:

```{r figure1}
ggplot(data = cars, aes(x = speed, y = dist)) + 
  geom_point() + 
  labs(x = "Speed of car (mph)",
       y = "Distance taken to stop (ft)",
       title = "Stopping distance increases with faster speeds",
       subtitle = "Based on 1920s study") +
  theme_classic()
```

Take note of the default code chunk options in the `setup` code chunk, and adjust individual code chunk options as needed. for example, unlike the rest of the Rmd files we worked in this semester, the default code chunk option is `echo = FALSE`, so you will need to set `echo  = TRUE` for any code chunks you would like to display in the blog. 


## Including links and images/videos

You can include [links](https://www.datadreaming.org/post/r-markdown-theme-gallery/) and there are a few ways to embed  images! Both options for embedding images below can be used interchangeably. They both work for png, pdf, jpg, and even gif formats, and both support filepaths that are either URLs (for videos, you can include links to any valid YouTube or Vimeo URLs; see [here](https://bookdown.org/yihui/rmarkdown/learnr-videos.html) for more details) or point to a location within your project directory. 

### Option 1: Markdown approach

![This is a figure caption. The artwork is called Safe Space by  [Kenesha Sneed](https://www.keneshasneed.com/#/safespace/)](img/Kenesha-Sneed_safe-space.jpeg)


### Option 2: Code chunk approach

```{r, fig.cap = "This is also figure caption"}
knitr::include_graphics("https://media.giphy.com/media/H7ZrrA9V2pd3Tehdds/giphy.gif")
```

## Including equations

Equations may be needed if you are explaining a new technique or perhaps providing some other relevant formulas in your exposition. There are two ways to include equations:

* Inline: $b \sim N(0, \sigma^2_b)$
* Display-style (displayed on its own line): $$\frac{\sigma^2_b}{\sigma^2_b + \sigma^2_e}$$

For typesetting equations appropriately, take a look at the *Symbols in math mode* section of this  [cheat sheet](https://users.dickinson.edu/~richesod/latex/latexcheatsheet.pdf)  (or do some extra Googling---there are *many* resources).


# You can even create tabs within your webpage if you want! {.tabset .tabset-fade .tabset-pills}

Every subsection heading (starting with `##`) until you create a new section heading (starting with `#`) will be a new tab.

## Bulleted list

You can make a bulleted list like this:

* item 1
* item 2
* item 3


## Numbered list

You can make a numbered list like this

1. First thing I want to say
2. Second thing I want to say
3. Third thing I want to say

# Customizing your blog design

As a *final* detail **only** if you have time, you can explore options for customizing the style of your blog. By default, we are using the `readthedown` theme from the [**rmdformats** package](https://github.com/juba/rmdformats) (see Line 6 of this file if you want to switch out themes). There are, I'm sure, many many many more similar packages with built in themes, or you can look into how to include a CSS code chunk to customize aspects of the current theme.  

There are some easy-to-change options that you can play around with:

* The theme itself (Line 6): `rmdformats::readthedown`, `rmdformats::downcute`, `rmdformats::robobook`, `rmdformats::material`,
  * For `downcute` only, you can add a new indented line below Line 6 with the code `downcute_theme: "chaos"` for the `downcute chaos` theme
  * I would *not* recommend the other themes that do not have the sidebar navigation
  
* Syntax highlighting options (Line 8, `highlight`): `"default"`, `"tango"`, `"pygments"`, `"kate"`, `"monochrome"`, `"espresso"`, `"zenburn"`, `"haddock"`, or `"textmate"` (or `NULL` for no syntax highlighting)


You can explore additional customizable YAML options by looking at the [**rmdformats** package](https://github.com/juba/rmdformats) page or running, for example, `?rmdformats::readthedown()` to see the help documentation for a particular theme from the package.
